{"version":3,"sources":["Heading/heading-arrow.svg","Endpoints/index.js","DataProvider/index.js","EndpointButton/index.js","Heading/index.js","Uptime/index.js","ResponseChart/index.js","App/index.js","serviceWorker.js","index.js"],"names":["module","exports","ENDPOINTS","id","method","route","UptimeContext","React","createContext","ResponseTimesContext","generateNewResponseTime","timestamp","Date","now","length","Math","round","random","DataProvider","children","useState","uptime","setUptime","reduce","accumulator","currentValue","initialValues","i","push","responseTimes","setResponseTimes","useEffect","interval","setInterval","amount","positive","min","max","clearInterval","Object","keys","currentKey","slice","Provider","value","EndpointButton","active","endpoint","onClick","responseTime","className","toFixed","Heading","alt","src","arrow","Uptime","useContext","percentage","width","height","animate","duration","data","x","y","innerRadius","labels","padding","standalone","style","fill","datum","color","fontFamily","fontSize","text","textAnchor","verticalAnchor","ResponseChart","currentEndpoint","containerComponent","Number","labelComponent","cornerRadius","flyoutStyle","strokeWidth","voronoiBlacklist","voronoiDimension","domain","y0","name","tickFormat","tick","format","tickLabels","dependentAxis","grid","stroke","App","currentEndpointKey","setCurrentEndpointKey","map","endpointId","endpointData","find","key","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.1c83a991.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/heading-arrow.0824148b.svg\";","// Which endpoints we want to track\nexport const ENDPOINTS = [\n  {\n    id: \"GET_PRODUCTS\",\n    method: \"GET\",\n    route: \"/products\"\n  },\n  {\n    id: \"GET_PRODUCT\",\n    route: \"/product/1\",\n    method: \"GET\"\n  },\n  {\n    id: \"PUT_ORDER\",\n    route: \"/order\",\n    method: \"PUT\"\n  },\n  {\n    id: \"POST_BASKET\",\n    route: \"/basket/1\",\n    method: \"POST\"\n  },\n  {\n    id: \"GET_USERS\",\n    route: \"/users\",\n    method: \"GET\"\n  }\n];\n\nexport default ENDPOINTS;\n","/*\n  Mocked response time data generated in this file.\n  It is then exposed through individual contexts to connect to in any component that needs it.\n*/\n\nimport React, { useEffect, useState } from \"react\";\nimport ENDPOINTS from \"../Endpoints\";\n\n// Mocked data fetching rate\nconst RESPONSE_TIME_INTERVAL = 60000;\n\n// How many response time values should be stored at a time\nconst MAX_RESPONSE_TIMES = 10;\n\n// Create new contexts to hold data\nexport const UptimeContext = React.createContext();\nexport const ResponseTimesContext = React.createContext();\n\n// Create a new random data point\nconst generateNewResponseTime = (timestamp = Date.now()) => ({\n  timestamp,\n  length: Math.round(Math.random() * 5 * 100) / 100\n});\n\nexport const DataProvider = ({ children }) => {\n  // Set up state with an initial value\n  const [uptime, setUptime] = useState(0.99);\n  // Set up state structure for endpoint response times\n  const [responseTimes, setResponseTimes] = useState(\n    // Create some initial historical values for each endpoint\n    ENDPOINTS.reduce((accumulator, currentValue) => {\n      const initialValues = [];\n\n      // Generate some response times before the current time\n      for (let i = 0; i < MAX_RESPONSE_TIMES; i++) {\n        // Backdate timestamps to just before now\n        initialValues.push(\n          generateNewResponseTime(\n            Date.now() - (MAX_RESPONSE_TIMES - i) * RESPONSE_TIME_INTERVAL\n          )\n        );\n      }\n\n      return {\n        ...accumulator,\n        [currentValue.id]: initialValues\n      };\n    }, {})\n  );\n\n  // Update uptime\n  useEffect(() => {\n    const interval = setInterval(() => {\n      // An amount between 0% and 5%\n      const amount = Math.round(Math.random() * 0.05 * 100) / 100;\n      const positive = Math.random() >= 0.5;\n\n      // Clamp uptime between 0 and 1\n      setUptime(uptime =>\n        Math.min(Math.max(uptime + (positive ? amount : -amount), 0), 1)\n      );\n    }, 60000);\n\n    return () => {\n      clearInterval(interval);\n    };\n  }, []);\n\n  // Update response times\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setResponseTimes(responseTimes =>\n        Object.keys(responseTimes).reduce((accumulator, currentKey) => {\n          // Get current endpoint data\n          const currentValue = responseTimes[currentKey];\n\n          // Append new data and clear out oldest one\n          return {\n            ...accumulator,\n            [currentKey]: [\n              ...currentValue.slice(-MAX_RESPONSE_TIMES + 1),\n              generateNewResponseTime()\n            ]\n          };\n        }, responseTimes)\n      );\n    }, RESPONSE_TIME_INTERVAL);\n\n    return () => {\n      clearInterval(interval);\n    };\n  }, []);\n\n  // Provide this data to the rest of the application\n  return (\n    <UptimeContext.Provider value={uptime}>\n      <ResponseTimesContext.Provider value={responseTimes}>\n        {children}\n      </ResponseTimesContext.Provider>\n    </UptimeContext.Provider>\n  );\n};\n\nexport default DataProvider;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"./styles.css\";\n\nconst EndpointButton = ({ active, endpoint, onClick, responseTime }) => (\n  <button\n    className={`endpointButton ${\n      active ? \"endpointButton--active\" : \"endpointButton--inactive\"\n    }`}\n    onClick={onClick}\n  >\n    <div className=\"endpointButton__container\">\n      <div className=\"endpointButton__endpoint\">\n        {/* Show endpoint method */}\n        <span className=\"endpointButton__method\">{endpoint.method}</span>\n        {/* Show endpoint route */}\n        <span className=\"endpointButton__route\">{endpoint.route}</span>\n      </div>\n      {/* Show latest response time */}\n      <div className=\"endpointButton__response-time\">\n        {responseTime.toFixed(2)}s\n      </div>\n    </div>\n  </button>\n);\n\nEndpointButton.propTypes = {\n  active: PropTypes.bool.isRequired,\n  endpoint: PropTypes.shape({\n    id: PropTypes.string.isRequired,\n    method: PropTypes.string.isRequired,\n    route: PropTypes.string.isRequired\n  }).isRequired,\n  onClick: PropTypes.func.isRequired,\n  responseTime: PropTypes.number.isRequired\n};\n\nexport default EndpointButton;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport arrow from \"./heading-arrow.svg\";\nimport \"./styles.css\";\n\n// Show styled heading for each section\nconst Heading = ({ children }) => (\n  <div className=\"heading\">\n    <img alt=\"\" className=\"heading__arrow\" src={arrow} />\n    <h2 className=\"heading__text\">{children}</h2>\n  </div>\n);\n\nHeading.propTypes = {\n  children: PropTypes.string.isRequired\n};\n\nexport default Heading;\n","import React, { useContext } from \"react\";\nimport { VictoryContainer, VictoryLabel, VictoryPie } from \"victory\";\nimport { UptimeContext } from \"../DataProvider\";\nimport \"./styles.css\";\n\nconst Uptime = () => {\n  // Connect to data context\n  const value = useContext(UptimeContext);\n\n  // Clamp uptime percentage between 0 and 1\n  const percentage = Math.min(Math.max(value, 0), 1);\n\n  return (\n    <div className=\"uptime\">\n      {/* Container required when `standalone` is false\n      `standalone` required to place label on top of pie chart */}\n      <VictoryContainer width={400} height={400}>\n        {/* Create a pie component */}\n        {/* Animate the changes in value */}\n        {/* Create data array comparing uptime to downtime */}\n        {/* Style pie to look like a circular line */}\n        <VictoryPie\n          animate={{ duration: 200 }}\n          data={[\n            { x: \"uptime\", y: percentage },\n            { x: \"downtime\", y: 1 - percentage }\n          ]}\n          innerRadius={150}\n          labels={() => null}\n          padding={0}\n          standalone={false}\n          style={{\n            data: {\n              fill: ({ datum }) => {\n                const color =\n                  datum.y > 0.98\n                    ? \"var(--success-color)\"\n                    : \"var(--warning-color)\";\n                return datum.x === \"uptime\" ? color : \"transparent\";\n              }\n            }\n          }}\n        />\n\n        {/* Apply label to show percentage value */}\n        <VictoryLabel\n          style={{\n            fontFamily: \"Roboto, sans-serif\",\n            fontSize: \"64px\"\n          }}\n          text={`${Math.round(percentage * 100)}%`}\n          textAnchor=\"middle\"\n          verticalAnchor=\"middle\"\n          x={200}\n          y={200}\n        />\n      </VictoryContainer>\n    </div>\n  );\n};\n\nexport default Uptime;\n","import React, { useContext } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { format } from \"date-fns\";\nimport {\n  VictoryArea,\n  VictoryAxis,\n  VictoryChart,\n  VictoryLine,\n  VictoryTooltip,\n  VictoryVoronoiContainer\n} from \"victory\";\nimport { ResponseTimesContext } from \"../DataProvider\";\nimport \"./styles.css\";\n\n// Show the response time for each endpoint in a line\nconst ResponseChart = ({ currentEndpoint }) => {\n  // Connect to data context\n  const responseTimes = useContext(ResponseTimesContext);\n  const data = responseTimes[currentEndpoint];\n\n  return (\n    <div className=\"responseChart\">\n      {/* Create a chart component */}\n      {/* Use a Voronoi container to allow labels to be displayed */}\n      {/* Pad out the rest of the chart component */}\n      <VictoryChart\n        containerComponent={\n          <VictoryVoronoiContainer\n            labels={({ datum }) => `${Number(datum.length).toFixed(2)}s`}\n            labelComponent={\n              <VictoryTooltip\n                cornerRadius={0}\n                flyoutStyle={{\n                  fill: \"var(--background-color)\",\n                  strokeWidth: 2\n                }}\n                style={{ fontFamily: \"Roboto, sans-serif\" }}\n              />\n            }\n            voronoiBlacklist={[\"danger-area\"]}\n            voronoiDimension=\"x\"\n          />\n        }\n        domain={{ y: [0, 5] }}\n      >\n        {/* Colour in the area over 3s */}\n        <VictoryArea\n          data={[\n            {\n              x: data[0].timestamp,\n              y0: 3,\n              y: 5\n            },\n            {\n              x: data.slice(-1)[0].timestamp,\n              y0: 3,\n              y: 5\n            }\n          ]}\n          name=\"danger-area\"\n          style={{\n            data: {\n              fill: \"var(--warning-background-color)\"\n            }\n          }}\n        />\n\n        {/* Create the horizontal axis */}\n        {/* Format labels to show as time */}\n        <VictoryAxis\n          tickFormat={tick => format(new Date(tick), \"h:mm a\")}\n          style={{\n            tickLabels: {\n              fontFamily: \"Roboto, sans-serif\",\n              fontSize: 10\n            }\n          }}\n        />\n\n        {/* Create the vertical axis */}\n        {/* Highlight any time over 3s as bad */}\n        {/* Format labels to show as response time value in seconds */}\n        <VictoryAxis\n          dependentAxis={true}\n          style={{\n            grid: {\n              stroke: ({ tick }) =>\n                tick >= 3 ? \"var(--warning-color)\" : \"var(--foreground-color)\",\n              strokeWidth: 1\n            },\n            tickLabels: {\n              fontFamily: \"Roboto, sans-serif\",\n              fontSize: 10\n            }\n          }}\n          tickFormat={tick => `${Number(tick).toFixed(2)}s`}\n        />\n\n        {/* Draw data as a line */}\n        {/* Tell Victory which values to use as its x and y values */}\n        <VictoryLine\n          data={data}\n          style={{\n            data: { stroke: \"var(--foreground-color)\", strokeWidth: 4 }\n          }}\n          x=\"timestamp\"\n          y=\"length\"\n        />\n      </VictoryChart>\n    </div>\n  );\n};\n\nResponseChart.propTypes = {\n  currentEndpoint: PropTypes.string.isRequired\n};\n\nexport default ResponseChart;\n","import React, { useContext, useState } from \"react\";\nimport EndpointButton from \"../EndpointButton\";\nimport Heading from \"../Heading\";\nimport Uptime from \"../Uptime\";\nimport ResponseChart from \"../ResponseChart\";\nimport { ResponseTimesContext } from \"../DataProvider\";\nimport ENDPOINTS from \"../Endpoints\";\nimport \"./styles.css\";\n\nconst App = () => {\n  // Connect to dashboard data\n  const responseTimes = useContext(ResponseTimesContext);\n\n  // Store which endpoint we're currently looking at\n  const [currentEndpointKey, setCurrentEndpointKey] = useState(\n    Object.keys(responseTimes)[0]\n  );\n\n  return (\n    <div className=\"app\">\n      <div className=\"app__sections\">\n        {/* Uptime pie chart */}\n        <section className=\"app__uptime\">\n          <Heading>Uptime</Heading>\n          <Uptime />\n        </section>\n\n        {/* List of endpoints */}\n        <section className=\"app__endpoints\">\n          <Heading>Endpoints</Heading>\n          <ul className=\"app__endpoints-list\">\n            {/* Iterate over endpoints and display latest data */}\n            {Object.keys(responseTimes).map(endpointId => {\n              // Get endpoint data\n              const endpointData = ENDPOINTS.find(\n                endpoint => endpoint.id === endpointId\n              );\n\n              return (\n                <li className=\"app__endpoints-list-item\" key={endpointId}>\n                  {/* Show button with latest data */}\n                  <EndpointButton\n                    active={currentEndpointKey === endpointId}\n                    endpoint={endpointData}\n                    responseTime={responseTimes[endpointId].slice(-1)[0].length}\n                    onClick={() => setCurrentEndpointKey(endpointId)}\n                  />\n                </li>\n              );\n            })}\n          </ul>\n        </section>\n\n        {/* Response time chart */}\n        <section className=\"app__response\">\n          <Heading>Response time</Heading>\n          <ResponseChart currentEndpoint={currentEndpointKey} />\n        </section>\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"normalize.css\";\nimport DataProvider from \"./DataProvider\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <DataProvider>\n    <App />\n  </DataProvider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}